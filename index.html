<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>360 tool</title>

    <script type="text/javascript" src="https://static.sketchfab.com/api/sketchfab-viewer-1.5.0.js"></script>

    <style type="text/css">
        .fab_frame iframe {
            position: absolute;
            z-index: 1;
            top: 0;
            left: 0;
            width: 70%;
            height: 100%;
        }
        .dashboard {
            position: absolute;
            z-index: 2;
            top: 0;
            right: 0;
            width: 25%;
            height: 100%;
        }
    </style>
</head>

<body>
<div class="fab_frame">
    <iframe src="" id="api-frame" allow="autoplay; fullscreen" allowfullscreen webkitallowfullscreen="true"></iframe>
</div>
<div class="dashboard" id="dashboard">
    <button id="screenshot">Preview snapshot</button>
    <button id="spin">Spin</button>
    <button id="record">Capture</button>
</div>

<script type="text/javascript" src="js/jszip.min.js"></script>
<script type="text/javascript" src="js/FileSaver.min.js"></script>
<script type="text/javascript">
    var fabview = document.getElementById( 'api-frame' );
    var uid = '4d4dfba6506d40b09b7eb34c642afab7'; // Wade cup
    // var uid = '31a9a4ae69834c42a4869d0610f32515'; // dragon headrest
    var client = new Sketchfab( '1.5.0', fabview );

    // CAREFUL --- img_warehouse is a global variable for storing blobs; only reference in capture()
    var img_warehouse = [];

    function capture( sketchfab_api, initial_camera, frame_index, total_frames ) {
        if ( frame_index === total_frames ) {
            var zip = new JSZip();

            for ( let img_index = 0; img_index < img_warehouse.length; img_index++ ) {
                zip.file( 'screenshot_' + img_index + '.png', img_warehouse[ img_index ] );
                if ( img_index === ( img_warehouse.length - 1 )) {
                    zip.generateAsync({ type:'blob' }).then( function( blob ) {
                        saveAs( blob, 'test.zip' );
                    }).then( function() {
                        img_warehouse = [];
                    });
                }
            }
            return;
        }

        let camera_promise = turntable( initial_camera, frame_index, total_frames );
        camera_promise.then( function( new_camera ) {
            lookat_wrapper( sketchfab_api, new_camera.position, new_camera.target, 0.0 );
            console.log( 'called lookat at frame ' + frame_index );
        }).then( function() {
            console.log( 'called screengrab at frame ' + frame_index );
            return screengrab( sketchfab_api, 1920, 1080 );
        }).then( function ( img_blob ) {
            img_warehouse.push( img_blob );
            console.log( 'called push at frame ' + frame_index );
        }).then( function() {
            capture( sketchfab_api, initial_camera, frame_index + 1, total_frames );
        });
    }

    // lookat_wrapper returns a Promise when setCameraLookAt finishes
    function lookat_wrapper( sketchfab_api, eye, target, duration ) {
        return new Promise(( resolve, reject ) => {
            sketchfab_api.lookat( eye, target, duration, function() {
                resolve();
            });
        });
    }

    // screengrab takes a screenshot of the specified resolution and returns the image as a blob
    function screengrab( sketchfab_api, width = 300, height = 300 ) {
        return new Promise(( resolve, reject ) => {
            sketchfab_api.getScreenShot( width, height, 'image/png', function( err, result ) {
                var img_data = atob( result.split( ',' )[ 1 ]);
                var buffer = new ArrayBuffer( img_data.length );
                var view = new Uint8Array( buffer );
                for ( var i = 0; i < img_data.length; i++ ) {
                    view[ i ] = img_data.charCodeAt( i ) & 0xff;
                }
                var img_blob = new Blob( [ buffer ], { type: 'image/png' });
                resolve( img_blob );
            });
        });
    }

    // turntable returns a camera object for a desired position around the model
    function turntable( initial_camera, frame_index, total_frames ) {
        return new Promise(( resolve, reject ) => {
            var increment = ( 2 * Math.PI ) / total_frames;
            var angle = increment * ( frame_index + 1 );
            var distance = Math.sqrt(
                Math.pow( initial_camera.target[ 0 ] - initial_camera.position[ 0 ], 2 ) +
                Math.pow( initial_camera.target[ 1 ] - initial_camera.position[ 1 ], 2 ));
            var x = initial_camera.target[ 0 ] + distance * Math.cos( angle );
            var y = initial_camera.target[ 1 ] + distance * Math.sin( angle );

            var new_camera = {
                position: [ x, y, initial_camera.position[ 2 ]],
                target: initial_camera.target.slice()
            };

            resolve( new_camera );
        });
    }

    var onSuccess = function( api ) {
        api.start();

        document.getElementById( 'screenshot' ).addEventListener( 'click', function() {
            let preview = screengrab( api, 120, 120 );

            preview.then( function( image ) {
                var thumbnail = document.createElement( 'img' );
                thumbnail.src = URL.createObjectURL( image );
                document.getElementById( 'dashboard' ).appendChild( thumbnail );
            });
        });

        document.getElementById( 'spin' ).addEventListener( 'click', function() {
            api.getCameraLookAt( function( err, camera ) {
                var total_frames = 300;
                var initial_camera = camera;

                for ( let frame_index = 0; frame_index < total_frames; frame_index++ ) {
                    let cam_promise = turntable( initial_camera, frame_index, total_frames );

                    cam_promise.then( function( new_camera ) {
                        setTimeout( function() {
                            return api.lookat( new_camera.position, new_camera.target, 0 );
                        }, frame_index * 70 );
                    });
                }
            });
        });

        document.getElementById( 'record' ).addEventListener( 'click', function() {
            api.getCameraLookAt( function( err, camera ) {
                capture( api, camera, 0, 4 );
            });
        });
    }

    client.init( uid, {
        success: onSuccess,
        error: function onError() {
            console.log( 'Viewer error' );
        },
        autostart: 1,
        annotations_visible: 0,
        camera: 0,
        preload: 1,
        double_click: 0,
        ui_fullscreen: 0,
        ui_stop: 0,
        ui_help: 0,
        ui_settings: 0,
        ui_inspector: 0,
        ui_vr: 0,
        ui_annotations: 0,
        ui_animations: 0,
        ui_infos: 0,
        transparent: 0 // set transparent background
    } );

</script>
</body>
</html>
